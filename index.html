<img src="logo.png" alt="logo" title="oh wow cool logo" height=135 width=175>
<h1 style="color:white;background-color: brown; text-align: center;" id="normie-s-competitive-programming-library">Normie&#39;s Competitive Programming Library</h1>
<p>This place is where I store templates for many different data structures and algorithms I used throughout my competitive programming career.</p>
<p>There&#39;s still a lot of stuff to add, but you can already find some useful templates of <abbr title="data structures and algorithms">DSAs</abbr> here.</p>
<p>I hope this helps people in their <abbr title="competitive programming">CP</abbr> journey.</p>
<h2>Index:</h2>
<ul>
    <li>
        Geometry
        <ul>
            <li><a href="Geometry/GeometryIface.hpp">Interface</a></li>
            <li><a href="Geometry/GeometryImpl.cpp">Implementation</a></li>
        </ul>
    </li>
    <li>
        Graphs
        <ul>
            <li>
                Clique
                <ul>
                    <li><a href="Graphs/Clique/BronKerboschClique.cpp">Bron-Kerbosch maximal clique iteration</a></li>
                </ul>
            </li>
            <li>
                Connectivity
                <ul>
                    <li><a href="Graphs/Connectivity/ArticulationPointsAndBridges.cpp">Articulation points and bridges</a></li>
                    <li><a href="Graphs/Connectivity/DominatorTree.cpp">Dominator tree</a></li>
                    <li><a href="Graphs/Connectivity/StronglyConnectedComponents.cpp">Strongly connected components</a></li>
                </ul>
            </li>
            <li>
                Disjoint-set union
                <ul>
                    <li><a href="Graphs/DSU/DisjointSetUnion.cpp">Without rollback</a></li>
                    <li><a href="Graphs/DSU/DSUWithRollbacks.cpp">With rollback</a></li>
                </ul>
            </li>
            <li>
                Flow and matching algorithms
                <ul>
                    <li><a href="Graphs/Flow and Matching/FordFulkersonMaxFlow.cpp">Ford-Fulkerson max flow algorithm (bugged)</a></li>
                    <li><a href="Graphs/Flow and Matching/DinicMaxFlow.cpp">Dinic's max flow algorithm</a></li>
                    <li><a href="Graphs/Flow and Matching/PushRelabelMaxFlow.cpp">Push-relabel max flow algorithm</a></li>
                    <li><a href="Graphs/Flow and Matching/HungarianAssignment.cpp">Hungarian min-cost matching algorithm</a></li>
                    <li><a href="Graphs/Flow and Matching/Kuhn.cpp">Kuhn matching algorithm</a></li>
                    <li><a href="Graphs/Flow and Matching/MinCostMaxFlow.cpp">Min cost flow algorithm</a></li>
                </ul>
            </li>
            <li>
                Shortest path algorithms
                <ul>
                    <li><a href="Graphs/Shortest Path/Dijkstra.cpp">Dijkstra (single pair)</a></li>
                    <li><a href="Graphs/Shortest Path/FloydWarshall.cpp">Floyd-Warshall (all pairs)</a></li>
                </ul>
            </li>
            <li>
                Tree algorithms
                <ul>
                    <li><a href="Graphs/Tree/Centroid.cpp">Find centroid</a></li>
                    <li><a href="Graphs/Tree/CentroidDecomp.cpp">Centroid decomposition</a></li>
                    <li><a href="Graphs/Tree/HLD.cpp">Heavy-light decomposition</a></li>
                    <li><a href="Graphs/Tree/LCA.cpp">Least common ancestor (<abbr title="range-minimum query">RMQ</abbr> method)</a></li>
                </ul>
            </li>
        </ul>
    </li>
    <li>
        Math
        <ul>
            <li><a href="Math/FastBinaryTransform.cpp">Fast binary transform</a></li>
            <li><a href="Math/NTT.cpp">Number theoretic transform</a></li>
            <li><a href="Math/PollardRhoFactorization.cpp">Pollard-rho factorization</a></li>
            <li><a href="Math/QuadraticResidue.cpp">Quadratic residue check</a></li>
            <li><a href="Math/SimpleBignum.cpp">Simple bignum implementation</a></li>
        </ul>
    </li>
    <li>
        Query Data Structures
        <ul>
            <li>
                <li><a href="Query Data Structures/SegmentTree.cpp">Segment tree</a></li>
                <li><a href="Query Data Structures/ImplicitSegmentTree.cpp">Implicit segment tree</a></li>
                <li><a href="Query Data Structures/PersistentSegTree.cpp">Persistent segment tree</a></li>
                <li><a href="Query Data Structures/MaxSegTreeWithBinarySearch.cpp">Segment tree with search (slow)</a></li>
                <li><a href="Query Data Structures/LightweightSegTree.cpp">Lightweight segment tree (no lazy propagation)</a></li>
                <li><a href="Query Data Structures/LiChaoTree.cpp">Li chao tree</a></li>
                <li><a href="Query Data Structures/STB_Add_Max_QMax.cpp">Segment tree beats (buggy)</a></li>
                <li><a href="Query Data Structures/SimpleConvexHull.cpp">Simple convex hull</a></li>
                <li><a href="Query Data Structures/Treap.cpp">Treap</a></li>
            </li>
        </ul>
    </li>
    <li>
        Strings
    </li>
    <li>
        Misc
    </li>
</ul>
<h3 id="todo-">Todo:</h3>
<p>Add basic stuff. For the time being, this library serves more to help me in my contests. I hope to improve it to make it more accessible for newcomers soon.</p>
<p>Add documentation. Some simpler DSAs haven&#39;t been documented.</p>
<p>Fix max segtree with search so that search operation is O(n*log<sub>2</sub>n).</p>
<p>Test more operations of treap.</p>